// use std::io::Read;

use crate::imports::*;

pub mod prelude {
    pub use super::{Certs, NginxConfig, ProxyConfig, ProxyKind, ServerKind};
}

const NGINX_CONFIG_PATH: &str = "/etc/nginx/";

pub fn nginx_service_detail() -> ServiceDetail {
    ServiceDetail::new(
        "NGINX HTTP proxy",
        "nginx",
        ServiceKind::Nginx,
        None,
        true,
        false,
        // None,
    )
}

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct Config {
    certs: Option<Certs>,
}

impl Service for Config {
    fn service_title(&self) -> String {
        "NGINX HTTP proxy".to_string()
    }

    fn service_name(&self) -> String {
        "nginx".to_string()
    }

    fn kind(&self) -> ServiceKind {
        ServiceKind::Nginx
    }

    fn origin(&self) -> Option<Origin> {
        None
    }

    fn enabled(&self) -> bool {
        true
    }

    fn managed(&self) -> bool {
        false
    }

    fn proxy_config(&self) -> Option<Vec<ProxyConfig>> {
        None
    }
}

impl Config {
    pub fn certs(&self) -> Option<Certs> {
        self.certs.clone()
    }

    pub fn disable_certs(&mut self) {
        self.certs = None;
    }

    pub fn enable_certs(&mut self, certs: Certs) {
        self.certs = Some(certs);
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Certs {
    pub key: String,
    pub crt: String,
}

impl Certs {
    pub fn new<K, C>(key: K, crt: C) -> Self
    where
        K: AsRef<Path>,
        C: AsRef<Path>,
    {
        Self {
            key: key.as_ref().display().to_string(),
            crt: crt.as_ref().display().to_string(),
        }
    }
}

pub enum ServerKind {
    Http {
        port: Option<u16>,
        fqdns: Vec<String>,
    },
    Tls {
        port: Option<u16>,
        certs: Certs,
        fqdns: Vec<String>,
    },
}

impl ServerKind {
    pub fn new(certs: &Option<Certs>) -> Self {
        match certs {
            Some(certs) => Self::tls(certs.clone()),
            None => Self::http(),
        }
    }

    pub fn tls(certs: Certs) -> Self {
        Self::Tls {
            port: Default::default(),
            fqdns: vec![],
            certs,
        }
    }

    pub fn http() -> Self {
        Self::Http {
            port: Default::default(),
            fqdns: vec![],
        }
    }

    pub fn with_port(mut self, port: u16) -> Self {
        match &mut self {
            Self::Http { port: p, .. } => *p = Some(port),
            Self::Tls { port: p, .. } => *p = Some(port),
        }

        self
    }

    pub fn with_fqdn<S: Display>(mut self, fqdn: Vec<S>) -> Self {
        let fqdns_ = fqdn
            .iter()
            .map(|fqdn| fqdn.to_string())
            .collect::<Vec<String>>();
        match &mut self {
            Self::Http { fqdns, .. } => fqdns.extend(fqdns_),
            Self::Tls { fqdns, .. } => fqdns.extend(fqdns_),
        }

        self
    }

    pub fn with_certs<S: Display>(mut self, key: S, crt: S) -> Self {
        match &mut self {
            Self::Tls { certs, .. } => {
                certs.key = key.to_string();
                certs.crt = crt.to_string();
            }
            _ => {
                panic!("Cannot set certificates for non-SSL server");
            }
        }

        self
    }
}

#[derive(Debug, Clone)]
pub enum ProxyKind {
    Http { port: u16 },
    Wrpc { port: u16 },
}

impl ProxyKind {
    pub fn http(port: u16) -> Self {
        Self::Http { port }
    }

    pub fn wrpc(port: u16) -> Self {
        Self::Wrpc { port }
    }
}

#[derive(Debug, Clone)]
pub struct ProxyConfig {
    pub title: String,
    pub path: String,
    pub proxy_kind: ProxyKind,
}

impl ProxyConfig {
    pub fn new<T, S>(title: T, path: S, proxy_kind: ProxyKind) -> Self
    where
        T: Display,
        S: Display,
    {
        Self {
            title: title.to_string(),
            path: path.to_string(),
            proxy_kind,
        }
    }
}

pub struct NginxConfig {
    pub server_kind: ServerKind,
    pub proxy_config: Vec<ProxyConfig>,
}

impl NginxConfig {
    pub fn new(server_kind: ServerKind, proxy_config: Vec<ProxyConfig>) -> Self {
        Self {
            server_kind,
            proxy_config,
        }
    }
}

impl Display for NginxConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let now = chrono::Local::now();
        let ts = now.format("%Y-%m-%d %H:%M:%S");

        writeln!(f, "#")?;
        writeln!(f, "# kHOST {}", khost::VERSION)?;
        writeln!(f, "# {ts}")?;
        writeln!(f, "#")?;
        writeln!(f, "# Do not edit this file!")?;
        writeln!(f, "#")?;
        writeln!(f, "server {{")?;

        match &self.server_kind {
            ServerKind::Http { port, fqdns } => {
                let port = port.unwrap_or(80);
                writeln!(f, "\tlisten {port};")?;
                writeln!(f, "\tlisten [::]:{port};")?;
                writeln!(f, "\tserver_name {};", fqdn::flatten(fqdns))?;
            }
            ServerKind::Tls { port, certs, fqdns } => {
                let port = port.unwrap_or(443);
                writeln!(f, "\tlisten {port} ssl;")?;
                writeln!(f, "\tlisten [::]:{port} ssl;")?;
                writeln!(f, "\tssl_certificate {}", certs.crt)?;
                writeln!(f, "\tssl_certificate_key {}", certs.key)?;
                writeln!(f, "\tserver_name {};", fqdn::flatten(fqdns))?;
            }
        }

        writeln!(f, "\tclient_max_body_size 1m;")?;
        writeln!(f)?;

        for proxy in self.proxy_config.iter() {
            let ProxyConfig {
                title,
                path,
                proxy_kind: proxy,
            } = proxy;
            writeln!(f, "\t# {title}")?;
            writeln!(f, "\tlocation {path} {{")?;
            writeln!(f, "\t\tproxy_http_version 1.1;")?;
            writeln!(f, "\t\tproxy_set_header Host $host;")?;
            writeln!(f, "\t\tproxy_set_header X-Real-IP $remote_addr;")?;

            match proxy {
                ProxyKind::Http { port } => {
                    writeln!(f, "\t\tproxy_pass http://127.0.0.1:{port}/;")?;
                }
                ProxyKind::Wrpc { port } => {
                    writeln!(f, "\t\tproxy_set_header Upgrade $http_upgrade;")?;
                    writeln!(f, "\t\tproxy_set_header Connection \"Upgrade\";")?;
                    writeln!(f, "\t\tproxy_pass http://127.0.0.1:{port}/;")?;
                }
            }

            writeln!(f, "\t}}")?;
            writeln!(f)?;
        }

        writeln!(f, "}}")?;
        // writeln!(f)?;

        Ok(())
    }
}

pub fn version() -> Option<String> {
    cmd!("nginx", "-v")
        .read()
        .ok()
        .map(|s| s.trim().to_string())
}

pub fn install(_ctx: &Context) -> Result<()> {
    step("Setting up NGINX...", || {
        sudo!("apt", "install", "-y", "nginx").run()
    })?;

    Ok(())
}

pub fn reload() -> Result<()> {
    sudo!("nginx", "-s", "reload").run()
}

pub fn status(ctx: &Context) -> Result<String> {
    systemd::status(&ctx.config.nginx)
}

// pub fn reconfigure() -> Result<()> {
//     // TODO
//     // let nginx_config = fs::read_to_string(PathBuf::from(NGINX_CONFIG_PATH).join("nginx.conf"))?;
//     Ok(())
// }

pub fn config_filename() -> PathBuf {
    PathBuf::from(NGINX_CONFIG_PATH).join("sites-enabled/khost.conf")
}

pub fn store(config: NginxConfig) -> Result<()> {
    sudo::fs::write(config_filename(), config.to_string())?;
    Ok(())
}

pub fn remove() -> Result<()> {
    step("Removing NGINX configuration", || {
        sudo::fs::remove_file(config_filename())?;
        reload()?;
        Ok(())
    })
}

pub fn reconfigure(ctx: &Context) -> Result<()> {
    step("Updating NGINX configuration...", || {
        let server_kind = ServerKind::new(&ctx.config.nginx.certs).with_fqdn(fqdn::get());
        let proxy_configs = ctx.proxy_configs();
        store(NginxConfig::new(server_kind, proxy_configs))?;
        reload()
    })
}
